Multi Threading concepts.
*************************

1. Introduction
2. The ways to define a Thread
- By extending Thread class
- By implementing Runnable(I)

3. Getting and Setting name of thread
4. Thread Priorities
5. The methods to prevent thread execution
- Yield()
- Join()
- Sleep()

6. Synchronization
7. Inter thread communication
8. Deadlock
9. Daemon Threads
10. Multi threading enhancements

________________________________________________________

1. Introduction

Multi Tasking
- Executing several task simultaneously is a concept of Multi Tasking.

There are two types of multi tasking
1. Process based multi tasking
2. Thread based multi tasking

Process based multi tasking
- Executing several task simultaneously were each task is a separate independent program(process) is called Process based multi tasking.
e.g. While typing a java program in the editor we can listen audio songs from same system, at the same time we can download a file from internet all these tasks will be executed simultaneously and independent of each other. Hence it is process based multi tasking.
- Process based multi tasking is best suitable at OS(operating system) level.


Thread based multi tasking
- Executing several task simultaneously where each task is a separate independent part of the same program is called Thread based multi tasking and each independent part is called a Thread.
- Thread based multi tasking is best suitable at Programmatic level.

Whether it is Process based or Thread based the main objective of multi tasking is to reduce response time of the system and to improve performance.

The main important application areas of multi threading are:
- to develop multi media graphics 
- to develop animation 
- to develop video games
- to develop web servers and application servers etc.

When compared with old languages developing multi threaded applications in java is very easy because java provides inbuilt support with rich API(Thread, Runnable, Thread group etc.)

________________________________________________________

Defining a Thread
- We can define a Thread in two ways: 
1. By extending Thread Class
2. By implementing Runnable Interface

1. By extending Thread Class
Case1. Thread Scheduler - Scheduling Thread
It is the part of JVM .
It is responsible to schedule threads, i.e. if multiple threads are waiting to get a chance of execution then in which order threads will be executed is decided by Thread Scheduler.
We can't expect exact algorithm for Thread Scheduler, it is varied from JVM to JVM. Hence we can't expect thread execution order and exact output.
Hence whenever situation comes to multi-threading there is no guarantee for exact output but we can provide several possible outputs.


Case2. Difference between t.start() and t.run()
In the case of t.start() a new thread will be created which is responsible for the execution of run().
But in the case of t.run() a new thread won't be created and run() will be executed just like a normal method call by main thread.
Hence in the above program if we replace t.start() with t.run() then the output is Child Thread execution followed by Main Thread, this total output produced by only main thread.


Case3. Importance of Thread Class start()
Thread class start() is register the thread with thread-scheduler and all other mandatory activities hence without thread class start() there is no chance of starting a new thread in java. Due to this thread class start() is considered as heart of multi-threading.

start(){
1. register this thread with thread-scheduler
2. perform all other mandatory activities
3. invoke run();
}


Case4. Overloading of run()
Overloading of run() is always possible but thread class start() can invoke no-argument run(), the other overloaded method we have to call explicitly like a normal method call.


Case5. If we are not Overriding run()
If we are not Overriding run() then thread class run() will be executed which has empty implementation hence we won't get any output.

class MyThread extends Thread{
// run() not overridden
}

public class ThreadDemo {
	public static void main(String[] args) {
		MyThread t = new MyThread();
		t.start();
	}
}

O/P -  no output
It is highly recommended to override run() otherwise don't go for multi-threading concept.

Case6. Overriding of start()
If we Override start() then our start() will be executed just like a normal method call and new thread won't be created.

class MyThread extends Thread{
	public void start() {
			System.out.println("start method");
	}
	public void run() {
			System.out.println("run method");
	}
}

public class ThreadDemo {
	public static void main(String[] args) {
		MyThread t = new MyThread();
		t.start();
		System.out.println("main method");
	}
}

O/P - start method
      main method
	  
	  
Note: It is not recommended to override start() otherwise don't go for multi-threading concept.



Case7. Overriding of start() with super.start();

class MyThread extends Thread{
	public void start() {
			super.start();//create child thread as well
			System.out.println("start method");
	}
	public void run() {
			System.out.println("run method");
	}
}

public class ThreadDemo {
	public static void main(String[] args) {
		MyThread t = new MyThread();
		t.start();
		System.out.println("main method");
	}
}
possible outputs
O/P - run method
	  start method
      main method
	  
O/P - start method
      run method
      main method
	  
O/P - start method
      main method
	  run method
	  
	  
Case8. Thread Lifecycle
* Born/Ready	MyThread t = new MyThread();
t.start();
* Ready/Runnable
If Thread-scheduler allocates processes
* Running
If run() completes
* Dead


Case9. After starting a thread if we are trying to restart the same thread then we will get runtime exception saying Illegal ThreadState Exception.

ublic class ThreadDemo {
	public static void main(String[] args) {
		MyThread t = new MyThread();
		t.start();
		System.out.println("main method");
		t.start(); //runtime exception saying Illegal ThreadState Exception.
	}
}



2. By implementing Runnable Interface
We can define a thread by implementing Runnable interface.
Runnable interface present in java.lang package and it contains only run(). [public void run();]
We will get mixed output and we can't tell exact output.

class MyRunnable implements Runnable{
	public void run() {
			//executed by child thread
			System.out.println("Child Thread");
	}
}

public class ThreadDemoRunnable {
	public static void main(String[] args) {
		MyRunnable r = new MyRunnable();
		Thread t1 = new Thread();
		Thread t2 = new Thread(r); //targeted thread
		***(Different Cases)***
		System.out.println("main thread"); //executed by main thread	
	}
}

********************************
MyRunnable r = new MyRunnable();
Thread t1 = new Thread();
Thread t2 = new Thread(r);
********************************

Case1. t1.start();
A new thread will be created and which is responsible for the execution of thread class run(), which has empty implementation.

Case2. t1.run();
No new thread will be created and thread class run() will be executed just like a normal method call.

Case3. t2.start();
A new thread will be created and which is responsible for the execution of MyRunnable class run().

Case4. t2.run();
A new thread won't be created and MyRunnable run() will be executed just like a normal method call.

Case5. r.start();
We will get compile time error saying MyRunnable class doesn't have start capability.
Cannot find symbol method start() location class MyRunnable.

Case6. r.run();
No new thread will be created and MyRunnable run() will be executed like normal method call.

*********************************************************************************************************************************

Which approach is best to define a thread?
- Among two ways of defining a thread implements runnable approach is recommended. 
  In the first approach our class always extends thread class, there is no chance of extending any other class hence we are missing inheritance benefit. But in the second approach while implementing runnable interface we can extend any other class. Hence we won't miss any inheritance benefit.
  Because of above reason implementing runnable interface approach is recommended than extending thread class.

  
Thread class constructors
1. Thread t = new Thread();
2. Thread t = new Thread(Runnable r);
3. Thread t = new Thread(String name);
4. Thread t = new Thread(Runnable r, String name);
5. Thread t = new Thread(ThreadGroup g, String name);
6. Thread t = new Thread(ThreadGroup g, Runnable r);
7. Thread t = new Thread(ThreadGroup g, Runnable r, String name);
8. Thread t = new Thread(ThreadGroup g, Runnable r, String name, long stacksize);



** Durgas approach to define a thread(Not recommended to use)
class MyThread extends Thread{
	public void run() {
			System.out.println("child thread");
	}
}

public class ThreadDemo {
	public static void main(String[] args) {
		MyThread t = new MyThread();
		Thread t1 = new Thread(t)
		t1.start();
		System.out.println("main thread");
	}
}

O/P - Child Thread
	  Main Thread
	  
	  OR
	  
	  Main Thread
	  Child Thread



Getting and Setting name of a thread	  
Every thread in java has some name it may be default name generated by JVM or customized name provided by programmer.
We can get and set name of a thread by using the following two methods of thread class.

public final String getName()
public final void setName(String name)

example.
public class ThreadDemo {
	public static void main(String[] args) {
		System.out.println(Thread.currentThread().getName()); //main
		MyThread t = new MyThread(); //Thread initialization
		System.out.println(t.getName()); //Thread-0
		Thread.currentThread().setName("Sudeep");
		System.out.println(Thread.currentThread().getName()); //Sudeep
	}
}


We can get current executing thread object by using Thread.currentThread()


************************************************************************************************************************

Thread Priorities


Thread.MIN_PRIORITY() -- 1
Thread.MAX_PRIORITY() -- 10
Thread.NORM_PRIORITY() -- 5

Thread-scheduler will use priorities while allocating processor.
The Thread which is having highest priority will get chance first.
If two thread having same priority then we can't expect exact execution order, it depends on Thread-scheduler.

Thread class define the following method to Get and Set priority of a thread.
public final int getPriority()
public final void setPriority(int p)

Allowed values range 1 to 10, otherwise run time exception IllegalArgument Exception.

eg. t.setPriority(7); --valid
    t.setPriority(17); --IllegalArgument Exception
	
	
* Default priority
The default priority only for the main thread is 5, but for all remaining thread default priority will be inherited from parent to child. i.e what ever parent thread has the same priority will be there for the child thread.

public class Test {
	public static void main(String[] args) {
		System.out.println(Thread.currentThread().getPriority());
		Thread.currentThread().setPriority(7);
		Thread t = new Thread();
		System.out.println(t.getPriority());
	}
}

O/P - 5
      7
	  
I we are commenting line 1, then both main and child threads have the same priority 5. hence we can't expect execution order and exact output.
If we are not commenting line 1, then main thread has a priority and child thread has a priority 10, hence child thread will get chance first followed by main thread. In this case output is.
Child thread 10 times followed by main thread 10 times.

Some platform won't provide proper support for thread priorities.

class MyThread extends Thread{
	public void run() {
		for(int i=0 ; i<10 ; i++){
			//executed by child thread
			System.out.println("Child Thread");
		}
	}
}

public class Test {
	public static void main(String[] args) {
    	MyThread t = new MyThread();
		System.out.println(Thread.currentThread().getPriority());
		Thread.currentThread().setPriority(1);
		t.start();
		for(int i = 0 ; i<10 ; i++){
			System.out.println("Main Thread");
		}
	}
}


We can prevent a thread execution by using the following methods.
1. yield()
2. join()
3. sleep()

1. yield()
- Yield() causes to pause current executing thread to give the chance for waiting threads of same priority.
If there is no waiting thread or all waiting threads have low priority then same thread can continue its execution.
If multiple threads are waiting with same priority then which waiting thread will get the chance? We can't expect it depends on thread-scheduler.
The thread which is Yielded when it will get the chance once again? It depends on thread-scheduler and we can't expect exactly.

public static native void yield();



class MyThreadYield extends Thread{
	
	public void run(){
		for(int i=0 ; i<10 ; i++){
			System.out.println("Child Thread");
			Thread.yield(); //Line 1
		}
	}
	
}

public class ThreadDemoYield {

	public static void main(String[] args) {

		MyThreadYield t = new MyThreadYield();
		t.start();
		for(int i=0 ; i<10 ; i++){
			System.out.println("Main Thread");
		}
		
	}

}

- In the above program if we comment Line 1 then both threads will get executed simultaneously and we can't expect which thread will complete first.
- If we are not commenting Line 1 then child thread always call yield() because of that main thread will get chance more number of times and the chance of completing main thread first is high.
Note - Some platforms won't provide proper support for yield().


2. join()
- If thread wants to wait until completing some other thread than we should go for join().
eg. If a thread t1 wants to wait until completing t2 than t1 has to call t2.join().
    If t1 executes t2.join() than immediately t1 will be entered into waiting state until t2 completes.
	Once t2 completes then t1 can continue its execution.
	
	
public final void join() throws InterruptedException
public final void join(long milisec) throws InterruptedException
public final void join(long milisec, int nanosec) throws InterruptedException

Every join() throws InterruptedException which is checked exception, hence compulsory we should handle this exception either by using try/catch or by throws keyword otherwise we will get compile time error.

Case1 - Waiting of main thread until completing child thread.