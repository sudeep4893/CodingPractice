Multi Threading concepts.
*************************

1. Introduction
2. The ways to define a Thread
- By extending Thread class
- By implementing Runnable(I)

3. Getting and Setting name of thread
4. Thread Priorities
5. The methods to prevent thread execution
- Yield()
- Join()
- Sleep()

6. Synchronization
7. Inter thread communication
8. Deadlock
9. Daemon Threads
10. Multi threading enhancements

________________________________________________________

1. Introduction

Multi Tasking
- Executing several task simultaneously is a concept of Multi Tasking.

There are two types of multi tasking
1. Process based multi tasking
2. Thread based multi tasking

Process based multi tasking
- Executing several task simultaneously were each task is a separate independent program(process) is called Process based multi tasking.
e.g. While typing a java program in the editor we can listen audio songs from same system, at the same time we can download a file from internet all these tasks will be executed simultaneously and independent of each other. Hence it is process based multi tasking.
- Process based multi tasking is best suitable at OS(operating system) level.


Thread based multi tasking
- Executing several task simultaneously where each task is a separate independent part of the same program is called Thread based multi tasking and each independent part is called a Thread.
- Thread based multi tasking is best suitable at Programmatic level.

Whether it is Process based or Thread based the main objective of multi tasking is to reduce response time of the system and to improve performance.

The main important application areas of multi threading are:
- to develop multi media graphics 
- to develop animation 
- to develop video games
- to develop web servers and application servers etc.

When compared with old languages developing multi threaded applications in java is very easy because java provides inbuilt support with rich API(Thread, Runnable, Thread group etc.)

________________________________________________________

Defining a Thread
- We can define a Thread in two ways: 
1. By extending Thread Class
2. By implementing Runnable Interface

1. By extending Thread Class
Case1. Thread Scheduler - Scheduling Thread
It is the part of JVM .
It is responsible to schedule threads, i.e. if multiple threads are waiting to get a chance of execution then in which order threads will be executed is decided by Thread Scheduler.
We can't expect exact algorithm for Thread Scheduler, it is varied from JVM to JVM. Hence we can't expect thread execution order and exact output.
Hence whenever situation comes to multi-threading there is no guarantee for exact output but we can provide several possible outputs.


Case2. Difference between t.start() and t.run()
In the case of t.start() a new thread will be created which is responsible for the execution of run().
But in the case of t.run() a new thread won't be created and run() will be executed just like a normal method call by main thread.
Hence in the above program if we replace t.start() with t.run() then the output is Child Thread execution followed by Main Thread, this total output produced by only main thread.


Case3. Importance of Thread Class start()
Thread class start() is register the thread with thread-scheduler and all other mandatory activities hence without thread class start() there is no chance of starting a new thread in java. Due to this thread class start() is considered as heart of multi-threading.

start(){
1. register this thread with thread-scheduler
2. perform all other mandatory activities
3. invoke run();
}


Case4. Overloading of run()
Overloading of run() is always possible but thread class start() can invoke no-argument run(), the other overloaded method we have to call explicitly like a normal method call.


Case5. If we are not Overriding run()
If we are not Overriding run() then thread class run() will be executed which has empty implementation hence we won't get any output.

class MyThread extends Thread{
// run() not overridden
}

public class ThreadDemo {
	public static void main(String[] args) {
		MyThread t = new MyThread();
		t.start();
	}
}

O/P -  no output
It is highly recommended to override run() otherwise don't go for multi-threading concept.

Case6. Overriding of start()
If we Override start() then our start() will be executed just like a normal method call and new thread won't be created.

class MyThread extends Thread{
	public void start() {
			System.out.println("start method");
	}
	public void run() {
			System.out.println("run method");
	}
}

public class ThreadDemo {
	public static void main(String[] args) {
		MyThread t = new MyThread();
		t.start();
		System.out.println("main method");
	}
}

O/P - start method
      main method
	  
	  
Note: It is not recommended to override start() otherwise don't go for multi-threading concept.



Case7. Overriding of start() with super.start();

class MyThread extends Thread{
	public void start() {
			super.start();//create child thread as well
			System.out.println("start method");
	}
	public void run() {
			System.out.println("run method");
	}
}

public class ThreadDemo {
	public static void main(String[] args) {
		MyThread t = new MyThread();
		t.start();
		System.out.println("main method");
	}
}
possible outputs
O/P - run method
	  start method
      main method
	  
O/P - start method
      run method
      main method
	  
O/P - start method
      main method
	  run method
	  
	  
Case8. Thread Lifecycle
* Born/Ready	MyThread t = new MyThread();
t.start();
* Ready/Runnable
If Thread-scheduler allocates processes
* Running
If run() completes
* Dead


Case9. After starting a thread if we are trying to restart the same thread then we will get runtime exception saying Illegal ThreadState Exception.

ublic class ThreadDemo {
	public static void main(String[] args) {
		MyThread t = new MyThread();
		t.start();
		System.out.println("main method");
		t.start(); //runtime exception saying Illegal ThreadState Exception.
	}
}



2. By implementing Runnable Interface
We can define a thread by implementing Runnable interface.
Runnable interface present in java.lang package and it contains only run(). [public void run();]